/*
* Vulnerable Server Script 01  -  I found this from a long time ago, this is edited a little bit
*/

#include <iostream.h>
#include <winsock.h>
#include <windows.h>
#pragma comment(lib, "wsock32.lib")
// Return message
#define ERROR_RETURN 1
#define OK_RETURN 0

// External Definitions: Integers, Strings, Constants, etc


// Functions Prototypes


// Functions
void a(char *str) {
    char buf[600] = "";
    strcpy(buf,str);
}

void Error(char *str) {
    // Show a message box with the error
    MessageBox(NULL, str, "Socket Error", MB_OK, MB_CANCEL);
    WSACleanup();
}

// Structures


int main(int argc, char **argv) {
    WORD sockVersion;
    WSADATA wsaData;
    int b_value;
    char Message[8000] = "";
    char buf[4000];
    u_short local_port;
    local_port = 400;
    // WSock32 initialized usage
    sockVersion = MAKEWORD(1,1);
    WSAStartup(sockVersion, &wsaData);
    // Server socket 
    socket server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == INVALID_SOCKET || server_sock == false) {
        Error("Socket Failed to initialize, socket()");
        WSACleanup;
        return ERROR_RETURN;
    }
    SOCKADDR_IN sin;
    sin.sin_family = PF_INET;
    sin.sin_port = htons(local_port);
    sin.sin_addr.s_addr = INADDR_ANY;
    // Bind the socket
    b_value = bind(server_sock, (LPSOCKADDR&sin, sizeof(sin));
    if (b_value == SOCKET_ERROR || b_value == false) {
        Error("Unable to bind socket, bind()");
        WSACleanup();
        return ERROR_RETURN;
    }
    // Get the socket to listen on
    b_value = listen(server_sock, 10);
    if (b_value == SOCKET_ERROR || b_value == false) {
        Error("Unable to bind and listen()");
        WSACleanup();
        return ERROR_RETURN;
    }
    // Wait for the connection
    SOCKET client_sock;
    client_sock = accept(server_sock, NULL, NULL);
    if (client_sock == INVALID_SOCKET || client_sock == false || client_sock != true) {
        Error("Unable to accept connection, accept()");
        WSACleanup();
        return ERROR_RETURN;
    }
    int bytes_recv = SOCKET_ERROR;
    while (bytes_recv == SOCKET_ERROR) {
        bytes_recv = recv(client_sock, Message, 8000, 0);
        if (bytes_recv == 0 || bytes_recv == WSACONNRESET || bytes_recv == false || bytes_recv != true) {
            printf("\n[-] Connection was closed on the client side...\n");
            break;
        }
    }
    // Pass the data recieved to the function 'a'
    a(Message);
    // Close the socket on the client side
    closesocket(client_sock);
    // Close the socket on the server side
    closesocket(server_sock);
    WSACleanup();
    // Return a successful connection
    return OK_RETURN;
}
